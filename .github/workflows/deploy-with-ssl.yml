name: Deploy with SSL

on:
  push:
    branches:
      - production
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      ssl_domain:
        description: 'Domain for SSL certificate'
        required: false
        type: string
      ssl_email:
        description: 'Email for SSL notifications'
        required: false
        type: string
      ssl_subdomains:
        description: 'Comma-separated subdomains'
        required: false
        default: 'www,api'
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}

      - name: Add VPS to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: Generate .env file
        run: |
          echo "${{ vars.APP_ENV }}" > .env

      - name: Add SSL environment variables
        run: |
          # Add SSL configuration if provided
          if [ -n "${{ github.event.inputs.ssl_domain }}" ] && [ -n "${{ github.event.inputs.ssl_email }}" ]; then
            echo "" >> .env
            echo "# SSL Configuration" >> .env
            echo "SSL_DOMAIN=${{ github.event.inputs.ssl_domain }}" >> .env
            echo "SSL_EMAIL=${{ github.event.inputs.ssl_email }}" >> .env
            echo "SSL_SUBDOMAINS=${{ github.event.inputs.ssl_subdomains || 'www,api' }}" >> .env
          fi

      - name: Debug .env file
        run: |
          echo "Checking if .env file was generated:"
          ls -la .env
          echo ""
          echo "SSL variables in .env:"
          grep -i ssl .env || echo "No SSL variables found in .env"
          echo ""
          echo "First few lines of .env file:"
          head -10 .env

      - name: Deploy to VPS
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PATH: ${{ secrets.VPS_PATH }}
          SSL_DOMAIN: ${{ github.event.inputs.ssl_domain }}
          SSL_EMAIL: ${{ github.event.inputs.ssl_email }}
          SSL_SUBDOMAINS: ${{ github.event.inputs.ssl_subdomains || 'www,api' }}
        run: |
          # Copy the generated .env file to the server
          scp .env ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:${{ secrets.VPS_PATH }}/.env

          ssh ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
            cd ${{ secrets.VPS_PATH }}

            # Pull latest changes
            git fetch origin
            git reset --hard origin/${{ github.event.inputs.environment || 'production' }}

            # Make SSL setup script executable
            chmod +x ssl-setup.sh

            # Determine which compose file to use
            COMPOSE_FILE="docker-compose.yml"
            if [ -n "$SSL_DOMAIN" ] && [ -n "$SSL_EMAIL" ]; then
              COMPOSE_FILE="docker-compose.ssl.yml"
              echo "Using SSL-enabled Docker Compose configuration"
            else
              echo "Using standard Docker Compose configuration"
            fi

            # Stop existing containers
            docker-compose -p quickform_${{ github.event.inputs.environment || 'production' }} down

            # Build new containers
            docker-compose -f $COMPOSE_FILE -p quickform_${{ github.event.inputs.environment || 'production' }} build --no-cache

            # Start containers
            docker-compose -f $COMPOSE_FILE -p quickform_${{ github.event.inputs.environment || 'production' }} up -d

            # Wait for services to be ready
            echo "Waiting for services to be ready..."
            sleep 30

            # Run database migrations
            docker-compose -f $COMPOSE_FILE -p quickform_${{ github.event.inputs.environment || 'production' }} exec -T app php artisan migrate --force

            # Clear caches
            docker-compose -f $COMPOSE_FILE -p quickform_${{ github.event.inputs.environment || 'production' }} exec -T app php artisan config:clear
            docker-compose -f $COMPOSE_FILE -p quickform_${{ github.event.inputs.environment || 'production' }} exec -T app php artisan cache:clear
            docker-compose -f $COMPOSE_FILE -p quickform_${{ github.event.inputs.environment || 'production' }} exec -T app php artisan route:clear
            docker-compose -f $COMPOSE_FILE -p quickform_${{ github.event.inputs.environment || 'production' }} exec -T app php artisan view:clear

            # Optimize for production
            docker-compose -f $COMPOSE_FILE -p quickform_${{ github.event.inputs.environment || 'production' }} exec -T app php artisan config:cache
            docker-compose -f $COMPOSE_FILE -p quickform_${{ github.event.inputs.environment || 'production' }} exec -T app php artisan route:cache
            docker-compose -f $COMPOSE_FILE -p quickform_${{ github.event.inputs.environment || 'production' }} exec -T app php artisan view:cache

            # Set proper permissions
            docker-compose -f $COMPOSE_FILE -p quickform_${{ github.event.inputs.environment || 'production' }} exec -T app chown -R www-data:www-data storage bootstrap/cache

            # Setup SSL auto-renewal if SSL is enabled
            if [ -n "$SSL_DOMAIN" ] && [ -n "$SSL_EMAIL" ]; then
              echo "Setting up SSL auto-renewal..."
              
              # Create renewal script
              cat > /usr/local/bin/renew-ssl-docker.sh << 'RENEWAL_EOF'
#!/bin/bash
# SSL Certificate Renewal Script for Docker

LOG_FILE="/var/log/ssl-renewal.log"
PROJECT_NAME="quickform_${{ github.event.inputs.environment || 'production' }}"
COMPOSE_FILE="${{ secrets.VPS_PATH }}/docker-compose.ssl.yml"

# Renew certificates
docker-compose -f $COMPOSE_FILE -p $PROJECT_NAME exec -T certbot certbot renew --quiet --webroot -w /var/www/html

# Reload nginx if certificates were renewed
if [ $? -eq 0 ]; then
  docker-compose -f $COMPOSE_FILE -p $PROJECT_NAME exec -T nginx nginx -s reload
  echo "$(date): SSL certificates renewed successfully" >> $LOG_FILE
else
  echo "$(date): SSL certificate renewal failed" >> $LOG_FILE
fi
RENEWAL_EOF

              chmod +x /usr/local/bin/renew-ssl-docker.sh

              # Add to crontab if not already present
              if ! crontab -l 2>/dev/null | grep -q "renew-ssl-docker.sh"; then
                (crontab -l 2>/dev/null; echo "0 0,12 * * * /usr/local/bin/renew-ssl-docker.sh") | crontab -
                echo "SSL auto-renewal cron job added"
              fi
            fi

            echo "Deployment completed successfully!"
          EOF

      - name: Verify deployment
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PATH: ${{ secrets.VPS_PATH }}
          SSL_DOMAIN: ${{ github.event.inputs.ssl_domain }}
        run: |
          echo "Verifying deployment on server:"
          ssh ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} "cd ${{ secrets.VPS_PATH }} && echo 'Docker containers:' && docker-compose ps && echo 'SSL variables in .env:' && grep -i ssl .env || echo 'No SSL variables found'"

      - name: Health check
        run: |
          sleep 30
          
          # Determine health check URL
          if [ -n "${{ github.event.inputs.ssl_domain }}" ]; then
            HEALTH_URL="https://${{ github.event.inputs.ssl_domain }}/health"
            echo "Testing SSL health check at: $HEALTH_URL"
          else
            HEALTH_URL="${{ secrets.VPS_URL }}/health"
            echo "Testing HTTP health check at: $HEALTH_URL"
          fi
          
          # Test health endpoint
          curl -f -k "$HEALTH_URL" || exit 1

      - name: SSL verification (if SSL enabled)
        if: github.event.inputs.ssl_domain != ''
        run: |
          sleep 10
          
          # Test SSL certificate
          echo "Testing SSL certificate for ${{ github.event.inputs.ssl_domain }}..."
          
          # Check if certificate exists and is valid
          if echo | openssl s_client -servername "${{ github.event.inputs.ssl_domain }}" -connect "${{ github.event.inputs.ssl_domain }}:443" 2>/dev/null | openssl x509 -noout -dates; then
            echo "‚úÖ SSL certificate is valid"
          else
            echo "‚ùå SSL certificate verification failed"
            exit 1
          fi

      - name: Notify deployment status
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "‚úÖ Deployment to ${{ github.event.inputs.environment || 'production' }} successful!"
            if [ -n "${{ github.event.inputs.ssl_domain }}" ]; then
              echo "üîê SSL certificate installed for ${{ github.event.inputs.ssl_domain }}"
            fi
          else
            echo "‚ùå Deployment to ${{ github.event.inputs.environment || 'production' }} failed!"
          fi 